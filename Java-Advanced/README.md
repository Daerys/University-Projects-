## Домашнее задание 1. Обход файлов

1. Разработайте класс Walk, осуществляющий подсчет хеш-сумм файлов.
    1. Формат запуска:
       `java Walk <входной файл> <выходной файл>`

    2. Входной файл содержит список файлов, которые требуется обойти.
    3. Выходной файл должен содержать по одной строке для каждого файла. Формат строки:
       `<шестнадцатеричная хеш-сумма> <путь к файлу>`

    4. Для подсчета хеш-суммы используйте алгоритм [SHA-256](https://en.wikipedia.org/wiki/SHA-2) (поддержка есть в
       стандартной библиотеке).
    5. Если при чтении файла возникают ошибки, укажите в качестве его хеш-суммы все нули.
    6. Кодировка входного и выходного файлов — *UTF-8*.
    7. Размеры файлов могут превышать размер оперативной памяти.
    8. Пример
   <table class="tg">
   <thead>
     <tr>
       <th class="tg-0pky">Входной файл</th>
     </tr>
   </thead>
   <tbody>
     <tr>
       <td class="tg-0pky">samples/1<br>samples/12<br>samples/123<br>samples/1234<br>samples/1<br>samples/binary<br>samples/no-such-file</td>
     </tr>
     <tr>
       <td class="tg-0pky">Выходной файл</td>
     </tr>
     <tr>
       <td class="tg-0pky">6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b samples/1<br>6b51d431df5d7f141cbececcf79edf3dd861c3b4069f0b11661a3eefacbba918 samples/12<br>a665a45920422f9d417e4867efdc4fb8a04a1f3fff1fa07e998e86f7f7a27ae3 samples/123<br>03ac674216f3e15c761ee1a5e255f067953623c8b388b4459e13f978d7c846f4 samples/1234<br>6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b samples/1<br>40aff2e9d2d8922e47afd4648e6967497158785fbd1da870e7110266bf944880 samples/binary<br>0000000000000000000000000000000000000000000000000000000000000000 samples/no-such-file</td>
     </tr>
   </tbody>
   </table> 

## Домашнее задание 2. Множество на массиве

1. Разработайте класс ArraySet, реализующий неизменяемое упорядоченное множество.
    1. Класс ArraySet должен реализовывать интерфейс SortedSet (простой вариант) или NavigableSet (сложный вариант).
    2. Все операции над множествами должны производиться с максимально возможной асимптотической эффективностью.
2. При выполнении задания следует обратить внимание на:
    1. Применение стандартных коллекций.
    2. Избавление от повторяющегося кода.

## Домашнее задание 3. Студенты

1. Разработайте класс StudentDB, осуществляющий поиск по базе данных студентов.
    1. Класс StudentDB должен реализовывать интерфейс StudentQuery (простой вариант) или GroupQuery (сложный вариант).
    2. Каждый метод должен состоять из ровно одного оператора. При этом длинные операторы надо разбивать на несколько
       строк.
2. При выполнении задания следует обратить внимание на:
    1. применение лямбда-выражений и потоков;
    2. избавление от повторяющегося кода.

## Домашнее задание 4. Implementor

1. Реализуйте класс Implementor, генерирующий реализации классов и интерфейсов.
    1. Аргумент командной строки: полное имя класса/интерфейса, для которого требуется сгенерировать реализацию.
    2. В результате работы должен быть сгенерирован java-код класса с суффиксом Impl, расширяющий (реализующий)
       указанный класс (интерфейс).
    3. Сгенерированный класс должен компилироваться без ошибок.
    4. Сгенерированный класс не должен быть абстрактным.
    5. Методы сгенерированного класса должны игнорировать свои аргументы и возвращать значения по умолчанию.
2. В задании выделяются три варианта:
    1. **Простой — Implementor должен уметь реализовывать только интерфейсы (но не классы). Поддержка generics не
       требуется.**
    2. ~~Сложный — Implementor должен уметь реализовывать и классы, и интерфейсы. Поддержка generics не требуется.~~
    3. ~~Бонусный — Implementor должен уметь реализовывать generic-классы и интерфейсы. Сгенерированный код должен иметь
       корректные параметры типов и не порождать UncheckedWarning.~~

## Домашнее задание 5. Jar Implementor

*Это домашнее задание связано с предыдущим и будет приниматься только с ним. Предыдущее домашнее задание отдельно сдать
будет нельзя.*

1. Создайте .jar-файл, содержащий скомпилированный Implementor и сопутствующие классы.
    1. Созданный .jar-файл должен запускаться командой java -jar.
    2. Запускаемый .jar-файл должен принимать те же аргументы командной строки, что и класс Implementor.
2. Модифицируйте `Implemetor` так, чтобы при запуске с аргументами -jar имя-класса файл.jar он генерировал .jar-файл с
   реализацией соответствующего класса (интерфейса).
3. Для проверки, кроме исходного кода так же должны быть представлены:
    1. скрипт для создания запускаемого .jar-файла, в том числе исходный код манифеста;
    2. запускаемый .jar-файл.
4. ~~Сложный вариант. Решение должно быть модуляризовано.~~

## Домашнее задание 6. Javadoc

*Это домашнее задание связано с двумя предыдущими и будет приниматься только с ними. Предыдущие домашнее задание
отдельно
сдать будет нельзя.*

1. Документируйте класс `Implementor` и сопутствующие классы с применением `Javadoc`.
    1. Должны быть документированы все классы и все члены классов, в том числе private.
    2. Документация должна генерироваться без предупреждений.
    3. Сгенерированная документация должна содержать корректные ссылки на классы стандартной библиотеки.
2. Для проверки, кроме исходного кода так же должны быть представлены:
    1. скрипт для генерации документации;
    2. сгенерированная документация.

## Домашнее задание 7. Итеративный параллелизм

1. Реализуйте класс `IterativeParallelism`, который будет обрабатывать списки в несколько потоков.
2. В простом варианте должны быть реализованы следующие методы:
    1. `minimum(threads, list, comparator)` — первый минимум;
    2. `maximum(threads, list, comparator)` — первый максимум;
    3. `all(threads, list, predicate)` — проверка, что все элементы списка, удовлетворяют предикату;
    4. `any(threads, list, predicate)` — проверка, что существует элемент списка, удовлетворяющий предикату.
    5. `count(threads, list, predicate)` — подсчёт числа элементов списка, удовлетворяющих предикату.
3. В сложном варианте должны быть дополнительно реализованы следующие методы:
    1. `filter(threads, list, predicate)` — вернуть список, содержащий элементы удовлетворяющие предикату;
    2. `map(threads, list, function)` — вернуть список, содержащий результаты применения функции;
    3. `join(threads, list)` — конкатенация строковых представлений элементов списка.
4. Во все функции передается параметр `threads` — сколько потоков надо использовать при вычислении. Вы можете
   рассчитывать, что число потоков относительно мало.
5. Не следует рассчитывать на то, что переданные компараторы, предикаты и функции работают быстро.
6. При выполнении задания **нельзя** использовать `Concurrency Utilities`.

## Домашнее задание 8. Параллельный запуск

1. Напишите класс `ParallelMapperImpl`, реализующий интерфейс `ParallelMapper`.
    ```
    public interface ParallelMapper extends AutoCloseable {
        <T, R> List<R> map(
            Function<? super T, ? extends R> f,
            List<? extends T> args
        ) throws InterruptedException;
    
        @Override
        void close();
    }
    ```
    1. Метод map должен параллельно вычислять функцию f на каждом из указанных аргументов (args).
    2. Метод close должен останавливать все рабочие потоки.
    3. Конструктор `ParallelMapperImpl(int threads)` создает threads рабочих потоков, которые могут быть использованы для
       распараллеливания.
    4. К одному `ParallelMapperImpl` могут одновременно обращаться несколько клиентов.
    5. Задания на исполнение должны накапливаться в очереди и обрабатываться в порядке поступления.
    6. В реализации не должно быть активных ожиданий.
2. Доработайте класс `IterativeParallelism` так, чтобы он мог использовать `ParallelMapper`.
    1. Добавьте конструктор `IterativeParallelism(ParallelMapper)`
    2. Методы класса должны делить работу на threads фрагментов и исполнять их при помощи `ParallelMapper`.
    3. При наличии `ParallelMapper` сам `IterativeParallelism` новые потоки создавать не должен.
    4. Должна быть возможность одновременного запуска и работы нескольких клиентов, использующих один `ParallelMapper`.
3. При выполнении задания всё ещё нельзя использовать `Concurrency Utilities`.

## ~~Домашнее задание 9. Web Crawler~~

1. ~~Напишите потокобезопасный класс `WebCrawler`, который будет рекурсивно обходить сайты.~~
    1. ~~Класс `WebCrawler` должен иметь конструктор~~

       ~~```public WebCrawler(Downloader downloader, int downloaders, int extractors, int perHost)```~~

        1. ~~`downloader` позволяет скачивать страницы и извлекать из них ссылки;~~
        2. ~~`downloaders` — максимальное число одновременно загружаемых страниц;~~
        3. ~~`extractors` — максимальное число страниц, из которых одновременно извлекаются ссылки;~~
        4. ~~`perHost` — максимальное число страниц, одновременно загружаемых c одного хоста. Для определения хоста следует
           использовать метод getHost класса `URLUtils` из тестов.~~
    2. ~~Класс `WebCrawler` должен реализовывать интерфейс `Crawler`~~

         ```
       public interface Crawler extends AutoCloseable {
             Result download(String url, int depth);
    
             void close();
         }
       ```

        1. ~~Метод `download` должен рекурсивно обходить страницы, начиная с указанного URL, на указанную глубину и
           возвращать список загруженных страниц и файлов. Например, если глубина равна 1, то должна быть загружена
           только указанная страница. Если глубина равна 2, то указанная страница и те страницы и файлы, на которые она
           ссылается, и так далее.~~
        2. ~~Метод `download` может вызываться параллельно в нескольких потоках.~~
        3. ~~Загрузка и обработка страниц (извлечение ссылок) должна выполняться максимально параллельно, с учетом
           ограничений на число одновременно загружаемых страниц (в том числе с одного хоста) и страниц, с которых
           загружаются ссылки.~~
        4. ~~Для распараллеливания разрешается создать до downloaders + extractors вспомогательных потоков.~~
        5. ~~Повторно загружать и/или извлекать ссылки из одной и той же страницы в рамках одного обхода (download)
           запрещается.~~
        6. ~~Метод `close` должен завершать все вспомогательные потоки.~~
    3. ~~Для загрузки страниц должен применяться `Downloader`, передаваемый первым аргументом конструктора.~~

         ```
          public interface Downloader {
             public Document download(final String url) throws IOException;
          }
         ```

        1. ~~Метод `download` загружает документ по его адресу (URL).~~
        2. ~~Документ позволяет получить ссылки по загруженной странице:~~
           ```
           public interface Document {
              List<String> extractLinks() throws IOException;
           }
           ```
        3. ~~Ссылки, возвращаемые документом, являются абсолютными и имеют схему `http` или `https`.~~

    4. ~~Должен быть реализован метод main, позволяющий запустить обход из командной строки~~
        1. ~~Командная строка~~
           ~~`WebCrawler url [depth [downloads [extractors [perHost]]]]`~~

        2. ~~Для загрузки страниц требуется использовать реализацию `CachingDownloader` из тестов.~~
2. ~~Версии задания~~
    1. ~~Простая — не требуется учитывать ограничения на число одновременных закачек с одного хоста (perHost >=
       downloaders).~~
    2. ~~Полная — требуется учитывать все ограничения.~~
    3. ~~Бонусная — сделать параллельный обход в ширину.~~
3. ~~Задание подразумевает активное использование `Concurrency Utilities`, в частности, в решении не должно быть
   «велосипедов», аналогичных/легко сводящихся к классам из `Concurrency Utilities`.~~

## Домашнее задание 10. HelloUDP

1. Реализуйте клиент и сервер, взаимодействующие по `UDP`.
2. Класс `HelloUDPClient` должен отправлять запросы на сервер, принимать результаты и выводить их на консоль.
    1. Аргументы командной строки:
        1. имя или ip-адрес компьютера, на котором запущен сервер;
        2. номер порта, на который отсылать запросы;
        3. префикс запросов (строка);
        4. число параллельных потоков запросов;
        5. число запросов в каждом потоке.
    2. Запросы должны одновременно отсылаться в указанном числе потоков. Каждый поток должен ожидать обработки своего запроса и выводить сам запрос и результат его обработки на консоль. Если запрос не был обработан, требуется послать его заново.
    3. Запросы должны формироваться по схеме `<префикс запросов><номер потока>_<номер запроса в потоке>`. 
3. Класс `HelloUDPServer` должен принимать задания, отсылаемые классом `HelloUDPClient` и отвечать на них.
    1. Аргументы командной строки:
        1. номер порта, по которому будут приниматься запросы;
        2. число рабочих потоков, которые будут обрабатывать запросы.
    2. Ответом на запрос должно быть `Hello, <текст запроса>`.
    3. Несмотря на то, что текущий способ получения ответа по запросу очень прост, сервер должен быть рассчитан на ситуацию, когда этот процесс может требовать много ресурсов и времени.
    4. Если сервер не успевает обрабатывать запросы, прием запросов может быть приостановлен. 

## Домашнее задание 11. Физические лица

1. Добавьте к банковскому приложению возможность работы с физическими лицами.
    1. У физического лица (`Person`) можно запросить имя, фамилию и номер паспорта.
    2. Удалённые физические лица (`RemotePerson`) должны передаваться при помощи удалённых объектов.
    3. Локальные физические лица (`LocalPerson`) должны передаваться при помощи механизма сериализации, и при последующем использовании не требовать связи с сервером.
    4. Должна быть возможность поиска физического лица по номеру паспорта, с выбором типа возвращаемого лица.
    5. Должна быть возможность создания записи о физическом лице по его данным.
    6. У физического лица может быть несколько счетов, к которым должен предоставляться доступ (через Person).
    7. Счёту физического лица с идентификатором _subId_ должен соответствовать банковский счёт с _id_ вида _passport:subId_.
    8. Изменения, производимые со счётом в банке (создание и изменение баланса), должны быть видны всем соответствующим `RemotePerson`, и только тем `LocalPerson`, которые были созданы после этого изменения.
    9. Изменения в счетах, производимые через `RemotePerson`, должны сразу применяться глобально, а производимые через `LocalPerson` – только локально для этого конкретного `LocalPerson`. 
2. Реализуйте приложение, демонстрирующее работу с физическим лицами.
    1. Аргументы командной строки: имя, фамилия, номер паспорта физического лица, номер счёта, изменение суммы счёта.
    2. Если информация об указанном физическом лице отсутствует, то оно должно быть добавлено. В противном случае – должны быть проверены его данные.
    3. Если у физического лица отсутствует счёт с указанным номером, то он создается с нулевым балансом.
    4. После обновления суммы счёта новый баланс должен выводиться на консоль. 
3. Напишите тесты, проверяющие вышеуказанное поведение как банка, так и приложения.
    1. Для реализации тестов рекомендуется использовать [JUnit](https://junit.org/junit5/) ([Tutorial](https://www.petrikainulainen.net/programming/testing/junit-5-tutorial-writing-our-first-test-class/)). Множество примеров использования можно найти в тестах.
    2. Если вы знакомы с другим тестовым фреймворком (например, [TestNG](https://testng.org/)), то можете использовать его.
    3. Добавьте jar-файлы используемых библиотек в каталог lib вашего репозитория.
    4. Нельзя использовать самописные фреймворки и тесты, запускаемые через main. 
4. Сложный вариант
    1. На каждом счету всегда должно быть неотрицательное количество денег.
    2. Тесты не должны рассчитывать на наличие запущенного RMI Registry.
    3. Создайте класс [BankTests](java-solutions/info/kgeorgiy/ja/vikulaev/bank/Tests/BankTests.java), запускающий тесты.
    4. Создайте скрипт, запускающий [BankTests](java-solutions/info/kgeorgiy/ja/vikulaev/bank/Tests/BankTests.java) и возвращающий код (статус) 0 в случае успеха и 1 в случае неудачи.
    5. Создайте скрипт, запускающий тесты с использованием стандартного подхода для вашего тестового фреймворка. Код возврата должен быть как в предыдущем пункте. 
5. Приложения и тесты должны находится в пакете [info.kgeorgiy.ja.*.bank](java-solutions/info/kgeorgiy/ja/vikulaev/bank) и его подпакетах. 

## Домашнее задание 12. HelloNonblockingUDP

1. Реализуйте клиент и сервер, взаимодействующие по UDP, используя только неблокирующий ввод-вывод.
2. Класс [HelloUDPNonblockingClient](java-solutions/info/kgeorgiy/ja/vikulaev/hello/HelloUDPNonblockingClient.java) должен иметь функциональность аналогичную [HelloUDPClient](java-solutions/info/kgeorgiy/ja/vikulaev/hello/HelloUDPClient.java), но без создания новых потоков.
3. Класс [HelloUDPNonblockingServer](java-solutions/info/kgeorgiy/ja/vikulaev/hello/HelloUDPNonblockingServer.java) должен иметь функциональность аналогичную [HelloUDPServer](java-solutions/info/kgeorgiy/ja/vikulaev/hello/HelloUDPServer.java), но все операции с сокетом должны производиться в одном потоке.
4. В реализации не должно быть активных ожиданий, в том числе через [Selector](https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/nio/channels/Selector.html).
5. Обратите внимание на выделение общего кода старой и новой реализации.
6. ~~Бонусный вариант. Клиент и сервер могут перед началом работы выделить O(число потоков) памяти. Выделять дополнительную память во время работы запрещено.~~